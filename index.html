<!DOCTYPE html>
<html>
<head>
    <title>Hello!</title>
    <style type="text/css">
        .outer {
            display: table;
            position: absolute;
            height: 100%;
            width: 100%;
        }

        .middle {
            display: table-cell;
            vertical-align: middle;
        }

        .inner {
            margin-left: auto;
            margin-right: auto;
            width: 500px;
        }

    </style>
</head>
<body style="background:black">

<div class="outer">
    <div class="middle">
        <div class="inner" style="width:500px; margin:0 auto">
            <canvas id="canvas-container" width="500" height="500"></canvas>
        </div>
    </div>
</div>

<script type="text/javascript">

    const canvas = document.getElementById('canvas-container');
    const context = canvas.getContext('2d');
    const fontSize = 18;

    context.font = fontSize + "px Lucida Grande";

    var centerX = canvas.width / 2;
    var centerY = canvas.height / 2;

    var maxAlpha = 0.8;
    const circles = [];
    const texts = [
        new Text(context, "Eugene Levenetc", null),
        new Text(context, "", null),
        new Text(context, "Github", "https://github.com/elevenetc"),
        new Text(context, "StackOverflow", "http://stackoverflow.com/users/798165/fox-in-socks?tab=profile"),
        new Text(context, "LinkedIn", "https://www.linkedin.com/in/elevenets"),
        new Text(context, "500px", "https://500px.com/e-levenetc"),
        new Text(context, "Google+", "https://plus.google.com/+EugeneLevenetc/posts"),
        new Text(context, "Twitter", "https://twitter.com/elevenetc")
    ];

    for (var i = 0; i < 20; i++) {
        var color = '#' + Math.floor(Math.random() * 16777215).toString(16);
        circles[i] = new Circle(centerX, centerY, maxAlpha, color);
    }

    canvas.addEventListener('mousemove', function (evt) {

        const rect = canvas.getBoundingClientRect();
        const mX = evt.clientX - rect.left;
        const mY = evt.clientY - rect.top;
        var foundItem = false;

        for (var i = 0; i < texts.length; i++) {
            var text = texts[i];
            if (text.contains(mX, mY)) {
                foundItem = true;
                text.mouseOverHandler();
            } else {
                text.mouseOutHandler();
            }
        }

        document.body.style.cursor = foundItem ? 'pointer' : 'default';

    }, false);

    canvas.addEventListener('mousedown', function (evt) {
        const rect = canvas.getBoundingClientRect();
        const mX = evt.clientX - rect.left;
        const mY = evt.clientY - rect.top;
        for (var i = 0; i < texts.length; i++) {
            var text = texts[i];
            if (text.contains(mX, mY)) text.mouseClickHandler();
        }
    }, false);

    window.requestAnimationFrame(draw);

    function draw() {
        context.clearRect(0, 0, 500, 500);
        drawCircles();
        drawTexts();
        window.requestAnimationFrame(draw);
    }

    function drawTexts() {
        context.globalCompositeOperation = "source-over";
        var yOffset = 0;
        const itemDistance = 0.3;
        const listOffset = (texts.length) * fontSize / 2;

        for (var i = 0; i < texts.length; i++) {
            var text = texts[i];
            var x = centerX - text.getWidth() / 2;
            var y = centerY - text.getHeight() / 2 + yOffset;
            text.onDraw(context, x, y  - listOffset, i);

            yOffset += text.getHeight() + fontSize * itemDistance;
        }
    }

    function drawCircles() {
        context.globalCompositeOperation = 'screen';
        for (var i = 0; i < circles.length; i++) circles[i].onDraw(context);
    }

    function Circle(x, y, maxAlpha, color) {

        this.color = color;

        const radius = 200;
        const maxScaleY = 1.1;
        const minScaleY = 0.9;
        const scaleYDiff = maxScaleY - minScaleY;
        var currentScaleY = getRandom(minScaleY, maxScaleY);

        const maxScaleX = 1.1;
        const minScaleX = 0.9;
        const scaleXDiff = maxScaleX - minScaleX;
        var currentScaleX = getRandom(minScaleX, maxScaleX);

        const scaleRateX = getRandom(0.001, 0.02);
        const scaleRateY = getRandom(0.001, 0.02);

        var xS = getRandom(1, 10);
        var yS = getRandom(1, 10);
        var alpha = 0;

        this.onDraw = function (context) {
            context.save();
            context.beginPath();
            context.setTransform(1, 0, 0, 1, x, y);
            context.scale(currentScaleX + minScaleX, currentScaleY + minScaleY);
            context.arc(0, 0, radius, 0, 2 * Math.PI);
            context.globalAlpha = alpha;
            context.fillStyle = this.color;
            context.fill();
            context.restore();

            currentScaleX = (Math.sin(xS) / 2 + 0.5) * scaleXDiff;
            currentScaleY = (Math.sin(yS) / 2 + 0.5) * scaleYDiff;
            xS += scaleRateX;
            yS += scaleRateY;

            if (alpha < maxAlpha) alpha += 0.01;
        }
    }

    function Text(context, text, link) {

        Text.prototype.overColor = '#3C3C3C';
        Text.prototype.outColor = 'black';

        var textMetrics = context.measureText(text);
        const height = fontSize;
        const width = textMetrics.width;
        var x;
        var y;
        this.color = "black";

        this.onDraw = function (context, x, y) {
            this.x = x;
            this.y = y;
            context.save();
            context.fillStyle = this.color;
            context.fillText(text, x, y + height);
            context.restore();
        };

        this.getText = function () {
            return text;
        };

        this.getWidth = function () {
            return width;
        };

        this.getHeight = function () {
            return height;
        };

        this.contains = function (x, y) {
            if(link == null) return false;
            if (x >= this.x && y >= this.y && this.x + width > x && this.y + height > y) {
                return true;
            } else {
                return false
            }
        };

        this.mouseOverHandler = function () {
            this.color = this.overColor;
        };

        this.mouseOutHandler = function () {
            this.color = this.outColor;
        };

        this.mouseClickHandler = function () {
            window.open(link, "_black");
        }
    }

    function getRandom(min, max) {
        return Math.random() * (max - min) + min;
    }


</script>

</body>
</html>